import _typeof from "@babel/runtime/helpers/esm/typeof";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import { parseColor, getColor, parseShadow } from 'style-utils';
import { getValue, startConvertToEndUnit, styleValueToArray } from '../utils';

var ArrayPlugin = function ArrayPlugin(value, key) {
  var _this = this;

  _classCallCheck(this, ArrayPlugin);

  this.value = value;
  this.key = key;
  this.start = [];
  this.tweenVars = {};
  this.vars = {};
  this.propsData = {
    data: [],
    unit: [],
    count: []
  };

  this.setDefaultData = function (type, splitStr) {
    var propsData = _this.propsData,
        value = _this.value;

    var v = _toConsumableArray(value);

    if (type === 'color') {
      v[3] = v[3] || 1;
    }

    propsData.type = type;
    propsData.data = v.map(function (c) {
      return !parseFloat(c) && parseFloat(c) !== 0 ? c : parseFloat(c);
    });
    propsData.unit = v.map(function (c) {
      return c.toString().replace(/[^a-z|%]/g, '');
    });
    propsData.count = v.map(function (c) {
      return c.toString().replace(/[^+|=|-]/g, '');
    });

    if (splitStr) {
      propsData.splitStr = splitStr;
    }
  };

  this.convertToMarksArray = function (unit, key, data, i) {
    var startUnit = (data || '').toString().replace(/[^a-z|%]/g, '');
    var endUnit = typeof i === 'number' ? unit[i] : undefined;

    if (startUnit === endUnit) {
      return parseFloat(data);
    } else if (!parseFloat(data) && parseFloat(data) !== 0) {
      return data;
    }

    return startConvertToEndUnit({
      target: _this.target,
      computedStyle: _this.computedStyle,
      style: key,
      value: data,
      startUnit: startUnit,
      endUnit: endUnit,
      isOriginWidth: key === 'transformOrigin' && !i
    });
  };

  this.getAnimStart = function () {
    var _tweenVars$key;

    var s = _this.startAt,
        target = _this.target,
        key = _this.key,
        propsData = _this.propsData,
        computedStyle = _this.computedStyle,
        tweenVars = _this.tweenVars;

    var startAt = _objectSpread({}, s);

    startAt = propsData.type === 'shadow' && startAt[key] ? parseShadow(startAt[key], key) : startAt;
    startAt = propsData.type === 'color' && startAt[key] ? parseColor(startAt[key]) : startAt;
    startAt = propsData.type === 'string' && startAt[key] ? startAt[key].split(/[\s|,]/) : startAt;
    var v = (_tweenVars$key = tweenVars[key]) !== null && _tweenVars$key !== void 0 ? _tweenVars$key : (computedStyle || target)[key];

    if (!v || v === 'none' || v === 'auto') {
      v = '';
    }

    if (!startAt[key]) {
      startAt[key] = propsData.type === 'shadow' ? parseShadow(v || '', key) : v;
      startAt[key] = propsData.type === 'color' && startAt[key] ? parseColor(startAt[key]) : startAt[key];
      startAt[key] = propsData.type === 'string' && startAt[key] ? startAt[key].split(/[\s|,]/) : startAt[key];
    }

    if (styleValueToArray[key]) {
      var _startAt$key$, _startAt$key$2, _ref, _startAt$key$3;

      startAt[key][1] = (_startAt$key$ = startAt[key][1]) !== null && _startAt$key$ !== void 0 ? _startAt$key$ : startAt[key][0];
      startAt[key][2] = (_startAt$key$2 = startAt[key][2]) !== null && _startAt$key$2 !== void 0 ? _startAt$key$2 : startAt[key][0];
      startAt[key][3] = (_ref = (_startAt$key$3 = startAt[key][3]) !== null && _startAt$key$3 !== void 0 ? _startAt$key$3 : startAt[key][1]) !== null && _ref !== void 0 ? _ref : startAt[key][0];
    }

    var inset = propsData.data.indexOf('inset');

    var d = _toConsumableArray(propsData.data);

    if (inset >= 0) {
      d.splice(inset, 1);
    }

    var startData = d.map(function (c, i) {
      if (typeof c === 'string') {
        return c;
      }

      if (startAt[key] && _typeof(startAt[key][i]) !== undefined) {
        return startAt[key][i];
      }

      return propsData.type === 'color' && i >= d.length - 1 ? 1 : 0;
    });
    var endUnit = propsData.unit;
    startData = startData.map(function (c, i) {
      if (parseFloat(c).toString() === 'NaN') {
        return c;
      }

      return _this.convertToMarksArray(endUnit, key, c, i);
    });
    _this.start = startData.concat(inset >= 0 ? 'inset' : []);
    return _this.start;
  };

  this.render = function (ratio) {
    var start = _this.start,
        propsData = _this.propsData;
    var type = propsData.type,
        splitStr = propsData.splitStr,
        data = propsData.data,
        count = propsData.count,
        unit = propsData.unit;
    var ratioData = data.map(function (c, i) {
      return typeof c === 'string' ? c : getValue(start[i], c, ratio, count[i], unit[i]);
    });

    switch (type) {
      case 'string':
        ratioData = ratioData.join(splitStr);
        break;

      case 'color':
        ratioData = getColor(ratioData);
        break;

      case 'shadow':
        {
          var startInset = start.indexOf('inset') >= 0;
          var endInset = ratioData.indexOf('inset') >= 0;

          if (startInset !== endInset) {
            console.warn('Warning: "box-shadow" inset is different, automatically convert to animation param.');
          }

          var r = endInset ? ratioData.filter(function (c) {
            return c !== 'inset';
          }) : ratioData;
          var s = r.slice(0, r.length - 4).map(function (a) {
            if (typeof a === 'number') {
              return "".concat(a, "px");
            }

            return a;
          });
          var c = getColor(r.slice(r.length - 4, r.length));
          ratioData = "".concat(s.join(' '), " ").concat(c, " ").concat(endInset ? 'inset' : '').trim();
          break;
        }

      default:
        break;
    }

    return ratioData;
  };

  var type = '';
  var splitStr = '';

  if (typeof value === 'string') {
    if (key.match(/color|fill|stroke/i)) {
      this.value = parseColor(value);
      type = 'color';
    } else if (key.match(/shadow/i)) {
      this.value = parseShadow(value, key);
      type = 'shadow';
    } else {
      splitStr = value.replace(/[^\s|,]/g, '').replace(/\s+/g, ' ');
      this.value = value.split(/[\s|,]/);
      type = 'string';
    }
  }

  this.setDefaultData(type, splitStr);
};

ArrayPlugin.className = 'ArrayPlugin';
export default ArrayPlugin;