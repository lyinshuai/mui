import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import { cssList, checkStyleName, getGsapType, isConvert, splitFilterToObject, getTransform, stylesToCss } from 'style-utils';
import { getComputedStyle, startConvertToEndUnit, getTransformValue, initFilterValue } from '../utils';
import Plugins from './';

var style = function style(props) {
  var _this = this;

  _classCallCheck(this, style);

  this.props = props;
  this.tweenVars = {};
  this.start = {};
  this.startAt = {};
  this.propsData = {
    data: {},
    type: {},
    unit: {},
    count: {},
    splitStr: {},
    isTransform: {}
  };

  this.setDefaultData = function () {
    var props = _this.props;

    for (var k in props) {
      // Object.keys(props).forEach((k: string) => {
      var value = props[k];
      var isArray = value.split && value.split(/\s+|,/).length > 1 || k.match(/color|fill|stroke/i) || k.match(/shadow/i);
      var isGradients = (k === 'background' || k === 'backgroundImage') && value.match(/[a-z|-]+\(([\s\S]*?)\)/gi);

      if (isGradients) {
        _this.propsData.data[k] = {
          value: value,
          plugin: Plugins.GradientsPlugin
        };
        continue;
      }

      if (isArray) {
        _this.propsData.data[k] = {
          value: value,
          plugin: Plugins.ArrayPlugin
        };
        continue;
      }

      var key = getGsapType(k);

      var data = _this.getTweenData(key, props[k]);

      _this.propsData.data[key] = data.data[key];
      _this.propsData.type[key] = data.type[key];
      _this.propsData.unit[key] = data.unit[key];
      _this.propsData.count[key] = data.count[key];
      _this.propsData.isTransform[key] = isConvert(key) === 'transform';

      if (data.splitStr[key]) {
        _this.propsData.splitStr[key] = data.splitStr[key];
      } //});

    }
  };

  this.getTweenData = function (key, v) {
    var data = {
      data: {},
      isTransform: {},
      type: {},
      unit: {},
      count: {},
      splitStr: {}
    };
    var value = v;
    data.data[key] = value; // data.type[key] = 'other';

    var dataIsString = typeof data.data[key] === 'string';
    data.unit[key] = dataIsString ? data.data[key].replace(/[^a-z|%]/g, '') : '';
    data.count[key] = dataIsString ? data.data[key].replace(/[^+|=|-]/g, '') : '';
    var d = dataIsString ? parseFloat(data.data[key].replace(/[a-z|%|=]/g, '')) : data.data[key];
    data.data[key] = !d && d !== 0 ? data.data[key] : d;
    return data;
  };

  this.getAnimStart = function () {
    var target = _this.target,
        root = _this.root,
        targetIndex = _this.targetIndex,
        propsData = _this.propsData,
        s = _this.startAt,
        start = _this.start,
        tweenVars = _this.tweenVars;
    var startAt = {};

    for (var c in s) {
      //Object.keys(s).forEach(c => {
      startAt[getGsapType(c)] = s[c]; //});
    }

    _this.computedStyle = _this.computedStyle || getComputedStyle(target);
    tweenVars.style = tweenVars.style || {};
    var transform;
    var filter;

    for (var key in propsData.data) {
      var _ref, _startAt$key;

      var item = propsData.data[key];

      if (item.plugin) {
        var plugin = new item.plugin(item.value, key);
        plugin.target = target;
        plugin.root = root;
        plugin.parent = parent;
        plugin.index = _this.index;
        plugin.targetIndex = targetIndex;
        plugin.tweenVars = root.vars[targetIndex] || {};
        plugin.startAt = _this.startAt;
        plugin.computedStyle = _this.computedStyle;
        item.plugin = plugin;
        start[key] = plugin.getAnimStart();
        continue;
      }

      var cssName = isConvert(key);
      var startData = (_ref = (_startAt$key = startAt[key]) !== null && _startAt$key !== void 0 ? _startAt$key : start[cssName]) !== null && _ref !== void 0 ? _ref : _this.computedStyle[cssName];

      if (!startData || startData === 'none' || startData === 'auto') {
        startData = '';
      }

      var endUnit = void 0;
      var startUnit = void 0;

      if (cssName === 'transform') {
        transform = transform || (start.transform ? _objectSpread({}, start.transform) : null);

        if (key in startAt) {
          transform = transform || getTransform();
          transform[key] = startAt[key];

          if (key === 'scale') {
            transform.scaleX = startAt[key];
            transform.scaleY = startAt[key];
          }
        } else {
          startData = _this.computedStyle[_this.transformName];
          endUnit = propsData.unit[key];
          transform = transform || getTransform(startData);
          var unitReg = /%|vw|vh|em|rem/i;

          if (endUnit && endUnit.match(unitReg)) {
            transform[key] = transform[key] && transform[key].toString().match(unitReg) ? parseFloat(transform[key]) : startConvertToEndUnit({
              target: target,
              computedStyle: _this.computedStyle,
              style: key,
              value: transform[key],
              endUnit: endUnit
            });
          }
        }

        start.transform = transform;
      } else if (cssName === 'filter') {
        var fKey = cssList.filterConvert[key] || key;
        filter = filter || start[cssName] || null;

        if (key in startAt) {
          filter = filter || {};
          filter[fKey] = startAt[key];
        } else {
          startData = _this.computedStyle[_this.filterName];
          endUnit = propsData.unit[key];
          filter = filter || (!startData || startData === 'none' || startData === 'auto' ? {} : splitFilterToObject(startData));
          filter[fKey] = filter[fKey] || initFilterValue[key] || 0;
        }

        startData = filter[fKey] || 0;
        startUnit = startData.toString().replace(/[^a-z|%]/g, '');
        endUnit = _this.propsData.unit[key];

        if (endUnit !== startUnit) {
          var _this$computedStyle;

          filter[fKey] = startConvertToEndUnit({
            target: target,
            computedStyle: _this.computedStyle,
            style: cssName,
            value: parseFloat(startData),
            startUnit: startUnit,
            endUnit: endUnit,
            fixed: ((_this$computedStyle = _this.computedStyle) === null || _this$computedStyle === void 0 ? void 0 : _this$computedStyle.position) === 'fixed'
          });
        }

        start[cssName] = filter;
      } else {
        // 计算单位
        endUnit = propsData.unit[cssName];
        startUnit = typeof startData === 'string' ? startData.replace(/[^a-z|%]/g, '') : '';

        if (endUnit !== startUnit) {
          var _this$computedStyle2;

          startData = startConvertToEndUnit({
            target: target,
            computedStyle: _this.computedStyle,
            style: cssName,
            value: parseFloat(startData),
            startUnit: startUnit,
            endUnit: endUnit,
            fixed: ((_this$computedStyle2 = _this.computedStyle) === null || _this$computedStyle2 === void 0 ? void 0 : _this$computedStyle2.position) === 'fixed'
          });
        }

        start[cssName] = parseFloat(startData || 0);
      }
    }

    return start;
  };

  this.render = function (ratio) {
    var propsData = _this.propsData,
        start = _this.start,
        t = _this.tweenVars;
    var tweenVars = t.style || {};

    if (start.transform && !tweenVars[_this.transformName]) {
      tweenVars[_this.transformName] = _objectSpread({}, start.transform);
    }

    if (start.filter && !tweenVars[_this.filterName]) {
      tweenVars[_this.filterName] = _objectSpread({}, start.filter);
    }

    var transform = tweenVars[_this.transformName];
    var filter = tweenVars[_this.filterName];
    var data = propsData.data,
        dataUnit = propsData.unit,
        dataCount = propsData.count,
        isTransform = propsData.isTransform;

    for (var key in data) {
      //Object.keys(data).forEach((key: string) => {
      var endValue = data[key];

      if (endValue.plugin) {
        tweenVars[key] = endValue.plugin.render(ratio);
        continue;
      }

      var isT = isTransform[key];
      var startValue = isT ? start.transform[key] : start[key];
      var unit = dataUnit[key];
      var count = dataCount[key];

      if (isT) {
        if (unit && unit.match(/%|vw|vh|em|rem/i)) {
          startValue = parseFloat(startValue);

          if (count.charAt(1) === '=') {
            transform[key] = startValue + endValue * ratio + (unit || 0);
          } else {
            transform[key] = (endValue - startValue) * ratio + startValue + (unit || 0);
          }
        } else if (key === 'scale') {
          var xStart = start.transform.scaleX;
          var yStart = start.transform.scaleY;

          if (count.charAt(1) === '=') {
            transform.scaleX = xStart + endValue * ratio;
            transform.scaleY = yStart + endValue * ratio;
          } else {
            transform.scaleX = (endValue - xStart) * ratio + xStart;
            transform.scaleY = (endValue - yStart) * ratio + yStart;
          }
        } else if (count.charAt(1) === '=') {
          transform[key] = startValue + endValue * ratio;
        } else {
          transform[key] = (endValue - startValue) * ratio + startValue;
        }

        transform.text = getTransformValue(tweenVars.transform);
      } else if (cssList.filter.indexOf(key) >= 0) {
        var fKey = cssList.filterConvert[key] || key;
        startValue = parseFloat(start.filter[fKey]) || 0;

        if (count.charAt(1) === '=') {
          filter[key] = startValue + endValue * ratio + (unit || 0);
        } else {
          filter[fKey] = (endValue - startValue) * ratio + startValue + (unit || 0);
        }

        filter.text = ''; //Object.keys(filter).forEach(filterKey => {

        for (var filterKey in filter) {
          if (filterKey === 'text') {
            continue;
          }

          filter.text = "".concat(filter.text, " ").concat(filterKey, "(").concat(filter[filterKey], ")").trim();
        } //});

      } else {
        var styleUnit = stylesToCss(key, 0);
        styleUnit = typeof styleUnit === 'number' ? 0 : styleUnit.replace(/[^a-z|%]/g, '');
        unit = unit || styleUnit;

        if (typeof endValue === 'string') {
          tweenVars[key] = endValue;
        } else if (count.charAt(1) === '=') {
          tweenVars[key] = startValue + endValue * ratio + unit;
        } else {
          tweenVars[key] = (endValue - startValue) * ratio + startValue + unit;
        }
      }
    }

    return tweenVars;
  };

  this.transformName = checkStyleName('transform');
  this.filterName = checkStyleName('filter') || 'filter';
  this.setDefaultData();
};

style.key = 'style';
style.className = 'style';
export default style;