import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import { svgPathProperties } from 'svg-path-properties';
import { checkStyleName, getTransform } from 'style-utils';
import { getComputedStyle, getTransformValue, startConvertToEndUnit } from '../utils';
import { rawPathToString, arrayToRawPath } from './path-utils';

var PathMotion = function PathMotion(value, key) {
  var _this = this;

  _classCallCheck(this, PathMotion);

  this.value = value;
  this.key = key;
  this.pathLength = 0;
  this.start = {};
  this.tweenVars = {};
  this.startAt = {};
  this.keys = ['x', 'y', 'rotate'];

  this.getAnimStart = function () {
    var target = _this.target,
        value = _this.value,
        tweenVars = _this.tweenVars;
    var tagName = target.tagName;

    if (tagName) {
      if (!_this.computedStyle) {
        _this.computedStyle = getComputedStyle(target);
      }

      if (tweenVars.style && tweenVars.style.transform) {
        _this.start = tweenVars.style.transform;
      } else {
        var transform = getTransform(_this.computedStyle[checkStyleName('transform')]);
        _this.start = transform;
        tweenVars.style = tweenVars.style || {};
        tweenVars.style.transform = tweenVars.style.transform || transform;
      }

      var _value$center = value.center,
          center = _value$center === void 0 ? ['50%', '50%'] : _value$center;
      _this.value.center = center.map(function (c, i) {
        return startConvertToEndUnit({
          target: target,
          computedStyle: _this.computedStyle,
          style: !i ? 'width' : 'height',
          value: parseFloat(c),
          startUnit: c.toString().replace(/[^a-z|%]/g, ''),
          useCurrentTarget: true
        });
      });
    } else {
      _this.start = {};

      _this.keys.forEach(function (key) {
        if (_this.value[key]) {
          _this.start[key] = 0;
        }
      });
    }
  };

  this.getPoint = function (r, offset) {
    var o = offset || 0;
    var p = _this.pathLength * r + o;
    return _this.path ? _this.path.getPointAtLength(p) : 0;
  };

  this.render = function (r) {
    var value = _this.value,
        target = _this.target,
        getPoint = _this.getPoint,
        tweenVars = _this.tweenVars;
    var tagName = target.tagName;
    var p = getPoint(r);
    var p0 = getPoint(r, 0.5);
    var p1 = getPoint(r, -0.5);
    var rotate = value.rotate,
        x = value.x,
        y = value.y,
        _value$center2 = value.center,
        center = _value$center2 === void 0 ? [0, 0] : _value$center2;
    var vars = tagName ? tweenVars.style || {} : tweenVars;

    if (tagName) {
      if (rotate) {
        vars.transform.rotate = Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
      }

      if (x) {
        vars.transform.translateX = p.x - parseFloat(center[0]);
      }

      if (y) {
        vars.transform.translateY = p.y - parseFloat(center[1]);
      }

      vars.transform.text = getTransformValue(vars.transform);
    } else {
      if (rotate) {
        vars.rotate = Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
      }

      if (x) {
        vars.x = p.x - parseFloat(center[0]);
      }

      if (y) {
        vars.y = p.y - parseFloat(center[1]);
      }
    }

    return vars;
  };

  if (typeof value === 'string') {
    this.value = {
      path: value
    };
  }

  this.keys.forEach(function (key) {
    if (!(key in _this.value)) {
      _this.value[key] = true;
    }
  });
  var _this$value = this.value,
      path = _this$value.path,
      pathVars = _this$value.pathVars;

  if (Array.isArray(path)) {
    path = pathVars.curviness !== 0 ? rawPathToString(arrayToRawPath(path, pathVars || {})) : path.map(function (item, i) {
      return "".concat(!i ? 'M' : 'L').concat(item.x, " ").concat(item.y);
    }).join('');
  }

  this.path = new svgPathProperties(path);
  this.pathLength = this.path.getTotalLength();
};

export { PathMotion as default };
PathMotion.key = 'style';
PathMotion.className = 'PathMotion';