'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var isEqual = _interopDefault(require('lodash.isequal'));

var opt = Object.prototype.toString;

function isArray(obj) {
  return opt.call(obj) === '[object Array]';
}

function isObject(obj) {
  return opt.call(obj) === '[object Object]';
}

function isString(obj) {
  return opt.call(obj) === '[object String]';
}

function isNumber(obj) {
  return opt.call(obj) === '[object Number]' && obj === obj;
}

function isBoolean(obj) {
  return opt.call(obj) === '[object Boolean]';
}

function isEmptyValue(obj) {
  return obj === undefined || obj === null || obj === '';
}

function isEmptyArray(obj) {
  return isArray(obj) && !obj.length;
}

function isEmptyObject(obj) {
  return isObject(obj) && !Object.keys(obj).length;
}

/**
 * @param options.trim trim string value
 * @param options.ignoreEmptyString used form type
 */
var Base = function Base(obj, options) {
  if (isObject(options) && isString(obj) && options.trim) {
    this.obj = obj.trim();
  } else if (isObject(options) && options.ignoreEmptyString && obj === '') {
    this.obj = undefined;
  } else {
    this.obj = obj;
  }
  if (isString(options.message)) {
    this.message = options.message;
  }
  this.type = options.type;
  this.error = null;
};

var prototypeAccessors = { not: { configurable: true },isRequired: { configurable: true },end: { configurable: true } };

prototypeAccessors.not.get = function () {
  this._not = !this._not;
  return this;
};

prototypeAccessors.isRequired.get = function () {
  if (isEmptyValue(this.obj) || isEmptyArray(this.obj)) {
    this.error = {
      value: this.obj,
      type: this.type,
      requiredError: true,
      message: this.message || ("" + (this._not ? '[NOT MODE]:': '') + (this.type) + " is required")
    };
  }
  return this;
};

prototypeAccessors.end.get = function () {
  return this.error;
};

Base.prototype.addError = function addError (message) {
  if (!this.error && message) {
    this.error = {
      value: this.obj,
      type: this.type,
      message: this.message || ("" + (this._not ? '[NOT MODE]:': '') + message)
    };
  }
};

Base.prototype.validate = function validate (expression, errorMessage) {
  var _expression = this._not ? expression : !expression;
  if (_expression) {
    this.addError(errorMessage);
  }
  return this;
};

Base.prototype.collect = function collect (callback) {
  callback && callback(this.error);
};

Object.defineProperties( Base.prototype, prototypeAccessors );

var StringValidater = /*@__PURE__*/(function (Base) {
  function StringValidater(obj, options) {
    Base.call(this, obj, Object.assign({}, options,
      {type: 'string'}));
    this.validate(
      options && options.strict ? isString(this.obj) : true,
      ("Expect string type but got " + (typeof this.obj))
    );
  }

  if ( Base ) StringValidater.__proto__ = Base;
  StringValidater.prototype = Object.create( Base && Base.prototype );
  StringValidater.prototype.constructor = StringValidater;

  var prototypeAccessors = { uppercase: { configurable: true },lowercase: { configurable: true } };

  StringValidater.prototype.maxLength = function maxLength (length) {
    return this.obj ? this.validate(
      this.obj.length <= length,
      ("Expect max length " + length + " but got " + (this.obj.length))
    ) : this;
  };

  StringValidater.prototype.minLength = function minLength (length) {
    return this.obj ? this.validate(
      this.obj.length >= length,
      ("Expect min length " + length + " but got " + (this.obj.length))
    ) : this;
  };

  StringValidater.prototype.length = function length (length$1) {
    return this.obj ? this.validate(
      this.obj.length === length$1,
      ("Expect length " + length$1 + " but got " + (this.obj.length))
    ) : this;
  };

  StringValidater.prototype.match = function match (pattern) {
    var isRegex = pattern instanceof RegExp;
    if (isRegex) {
      pattern.lastIndex = 0;
    }
    return this.validate(
      this.obj === undefined || (isRegex && pattern.test(this.obj)),
      ("`" + (this.obj) + "` is not match pattern " + pattern)
    );
  };

  prototypeAccessors.uppercase.get = function () {
    return this.obj ? this.validate(
      this.obj.toUpperCase() === this.obj,
      ("Expect `" + (this.obj) + "` to be uppercased")
    ) : this;
  };

  prototypeAccessors.lowercase.get = function () {
    return this.obj ? this.validate(
      this.obj.toLowerCase() === this.obj,
      ("Expect `" + (this.obj) + "` to be lowercased")
    ) : this;
  };

  Object.defineProperties( StringValidater.prototype, prototypeAccessors );

  return StringValidater;
}(Base));

var NumberValidater = /*@__PURE__*/(function (Base) {
  function NumberValidater(obj, options) {
    Base.call(this, obj, Object.assign({}, options,
      {type: 'number'}));
    this.validate(
      options && options.strict ? isNumber(this.obj) : true,
      ("Expect number type but got " + (typeof this.obj))
    );
  }

  if ( Base ) NumberValidater.__proto__ = Base;
  NumberValidater.prototype = Object.create( Base && Base.prototype );
  NumberValidater.prototype.constructor = NumberValidater;

  var prototypeAccessors = { positive: { configurable: true },negative: { configurable: true } };

  NumberValidater.prototype.min = function min (num) {
    return !isEmptyValue(this.obj) ? this.validate(
      this.obj >= num,
      ("`" + (this.obj) + "` is not greater than `" + num + "`")
    ) : this;
  };

  NumberValidater.prototype.max = function max (num) {
    return !isEmptyValue(this.obj) ? this.validate(
      this.obj <= num,
      ("`" + (this.obj) + "` is not less than `" + num + "`")
    ) : this;
  };

  NumberValidater.prototype.equal = function equal (num) {
    return !isEmptyValue(this.obj) ? this.validate(
      this.obj === num,
      ("`" + (this.obj) + "` is not equal to `" + num + "`")
    ) : this;
  };

  NumberValidater.prototype.range = function range (min, max) {
    return !isEmptyValue(this.obj) ? this.validate(
      this.obj >= min && this.obj <= max,
      ("`" + (this.obj) + "` is not in range `" + min + " ~ " + max + "`")
    ) : this;
  };

  prototypeAccessors.positive.get = function () {
    return !isEmptyValue(this.obj) ? this.validate(
      this.obj > 0,
      ("Expect number to be positive, but got `" + (this.obj) + "`")
    ) : this;
  };

  prototypeAccessors.negative.get = function () {
    return !isEmptyValue(this.obj) ? this.validate(
      this.obj < 0,
      ("Expect number to be negative, but got `" + (this.obj) + "`")
    ) : this;
  };

  Object.defineProperties( NumberValidater.prototype, prototypeAccessors );

  return NumberValidater;
}(Base));

var ArrayValidater = /*@__PURE__*/(function (Base) {
  function ArrayValidater(obj, options) {
    Base.call(this, obj, Object.assign({}, options,
      {type: 'array'}));
    this.validate(
      options && options.strict ? isArray(this.obj) : true,
      ("Expect array type but got `" + (this.obj) + "`")
    );
  }

  if ( Base ) ArrayValidater.__proto__ = Base;
  ArrayValidater.prototype = Object.create( Base && Base.prototype );
  ArrayValidater.prototype.constructor = ArrayValidater;

  var prototypeAccessors = { empty: { configurable: true } };

  ArrayValidater.prototype.length = function length (num) {
    return this.obj ? this.validate(
      this.obj.length === num,
      ("Expect array length " + num + " but got " + (this.obj.length))
    ) : this;
  };

  ArrayValidater.prototype.minLength = function minLength (num) {
    return this.obj ? this.validate(
      this.obj.length >= num,
      ("Expect min array length " + num + " but got " + (this.obj.length))
    ) : this;
  };

  ArrayValidater.prototype.maxLength = function maxLength (num) {
    return this.obj ? this.validate(
      this.obj.length <= num,
      ("Expect max array length " + num + " but got " + (this.obj.length))
    ) : this;
  };

  ArrayValidater.prototype.includes = function includes (arrays) {
    var this$1 = this;

    return this.obj ? this.validate(
      arrays.every(function (el) { return this$1.obj.indexOf(el) !== -1; }),
      ((JSON.stringify(this.obj)) + " is not includes " + (JSON.stringify(arrays)))
    ) : this;
  };

  ArrayValidater.prototype.deepEqual = function deepEqual (other) {
    return this.obj ? this.validate(
      isEqual(this.obj, other),
      ((JSON.stringify(this.obj)) + " is not deep equal with " + (JSON.stringify(other)))
    ) : this;
  };

  prototypeAccessors.empty.get = function () {
    return this.validate(
      isEmptyArray(this.obj),
      ("Expect empty array but got " + (JSON.stringify(this.obj)))
    );
  };

  Object.defineProperties( ArrayValidater.prototype, prototypeAccessors );

  return ArrayValidater;
}(Base));

var ObjectValidater = /*@__PURE__*/(function (Base) {
  function ObjectValidater(obj, options) {
    Base.call(this, obj, Object.assign({}, options,
      {type: 'object'}));
    this.validate(
      options && options.strict ? isObject(this.obj) : true,
      ("Expect object type but got `" + (this.obj) + "`")
    );
  }

  if ( Base ) ObjectValidater.__proto__ = Base;
  ObjectValidater.prototype = Object.create( Base && Base.prototype );
  ObjectValidater.prototype.constructor = ObjectValidater;

  var prototypeAccessors = { empty: { configurable: true } };

  ObjectValidater.prototype.deepEqual = function deepEqual (other) {
    return this.obj ? this.validate(
      isEqual(this.obj, other),
      ((JSON.stringify(this.obj)) + " is not deep equal with " + (JSON.stringify(other)))
    ) : this;
  };

  ObjectValidater.prototype.hasKeys = function hasKeys (keys) {
    var this$1 = this;

    return this.obj ? this.validate(
      keys.every(function (el) { return this$1.obj[el]; }),
      ((JSON.stringify(this.obj)) + " is not has keys " + keys)
    ) : this;
  };

  prototypeAccessors.empty.get = function () {
    return this.validate(
      isEmptyObject(this.obj),
      ("Expect empty object but got " + (JSON.stringify(this.obj)))
    );
  };

  Object.defineProperties( ObjectValidater.prototype, prototypeAccessors );

  return ObjectValidater;
}(Base));

var BooleanValidater = /*@__PURE__*/(function (Base) {
  function BooleanValidater(obj, options) {
    Base.call(this, obj, Object.assign({}, options,
      {type: 'boolean'}));
    this.validate(
      options && options.strict ? isBoolean(this.obj) : true,
      ("Expect boolean type but got " + (typeof this.obj))
    );
  }

  if ( Base ) BooleanValidater.__proto__ = Base;
  BooleanValidater.prototype = Object.create( Base && Base.prototype );
  BooleanValidater.prototype.constructor = BooleanValidater;

  var prototypeAccessors = { true: { configurable: true },false: { configurable: true } };

  prototypeAccessors.true.get = function () {
    return this.validate(
      this.obj === true,
      'Expect true but got false'
    );
  };

  prototypeAccessors.false.get = function () {
    return this.validate(
      this.obj === false,
      'Expect false but got true'
    );
  };

  Object.defineProperties( BooleanValidater.prototype, prototypeAccessors );

  return BooleanValidater;
}(Base));

var regexEmail = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var regexUrl = new RegExp('^(?!mailto:)(?:(?:http|https|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$', 'i');
var regexIp = /^(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})(\.(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})){3}$/;

var TypeValidater = /*@__PURE__*/(function (Base) {
  function TypeValidater(obj, options) {
    Base.call(this, obj, Object.assign({}, options,
      {type: 'type'}));
  }

  if ( Base ) TypeValidater.__proto__ = Base;
  TypeValidater.prototype = Object.create( Base && Base.prototype );
  TypeValidater.prototype.constructor = TypeValidater;

  var prototypeAccessors = { email: { configurable: true },url: { configurable: true },ip: { configurable: true } };

  prototypeAccessors.email.get = function () {
    return this.validate(
      this.obj === undefined || regexEmail.test(this.obj),
      ("Expect type email but got `" + (this.obj) + "`")
    );
  };

  prototypeAccessors.url.get = function () {
    return this.validate(
      this.obj === undefined || regexUrl.test(this.obj),
      ("Expect type url but got `" + (this.obj) + "`")
    );
  };

  prototypeAccessors.ip.get = function () {
    return this.validate(
      this.obj === undefined || regexIp.test(this.obj),
      ("Expect type ip but got `" + (this.obj) + "`")
    )
  };

  Object.defineProperties( TypeValidater.prototype, prototypeAccessors );

  return TypeValidater;
}(Base));

var CustomValidater = /*@__PURE__*/(function (Base) {
  function CustomValidater(obj, options) {
    Base.call(this, obj, Object.assign({}, options,
      {type: 'custom'}));
  }

  if ( Base ) CustomValidater.__proto__ = Base;
  CustomValidater.prototype = Object.create( Base && Base.prototype );
  CustomValidater.prototype.constructor = CustomValidater;

  var prototypeAccessors = { validate: { configurable: true } };

  prototypeAccessors.validate.get = function () {
    var _this = this;
    return function(validator, callback) {
      var ret;
      if (validator) {
        ret = validator(_this.obj, _this.addError.bind(_this));
        if (ret && ret.then) {
          if (callback) {
            ret.then(
              function () {
                callback && callback(_this.error);
              },
              function (e) {
                console.error(e);
              }
            );
          }
          return [ret, _this];
        } else {
          callback && callback(_this.error);
          return this.error;
        }
      }
    };
  };

  Object.defineProperties( CustomValidater.prototype, prototypeAccessors );

  return CustomValidater;
}(Base));

var Validate = function Validate(obj, options) {
  this.string = new StringValidater(obj, options);
  this.number = new NumberValidater(obj, options);
  this.array = new ArrayValidater(obj, options);
  this.object = new ObjectValidater(obj, options);
  this.boolean = new BooleanValidater(obj, options);
  this.type = new TypeValidater(obj, options);
  this.custom = new CustomValidater(obj, options);
};

function index (obj, options) {
  return new Validate(obj, options);
}
var Schema = function Schema(schema, options) {
  if ( options === void 0 ) options = {};

  this.schema = schema;
  this.options = options;
};

Schema.prototype.validate = function validate (values, callback) {
    var this$1 = this;

  if (!isObject(values)) {
    return;
  }
  var promises = [];
  var errors = null;
  function setError(key, error) {
    if (!errors) {
      errors = {};
    }
    if (!errors[key] || error.requiredError) {
      errors[key] = error;
    }
  }
  if (this.schema) {
    Object.keys(this.schema).forEach(function (key) {
      if (isArray(this$1.schema[key])) {
        this$1.schema[key].forEach(function (rule) {
          var type = rule.type;
          var message = rule.message;
          var bv;
          if (!type && !rule.validator) {
            throw ("You must specify a type to field " + key + "!");
          }
          if (type === 'email' || type === 'url' || type === 'ip') {
            bv = new Validate(values[key], Object.assign({}, this$1.options, {message: message})).type[type];
          } else if(rule.validator) {
            bv = new Validate(values[key], Object.assign({}, this$1.options, {message: message})).custom.validate(rule.validator);
            if (Object.prototype.toString.call(bv) === '[object Array]' && bv[0].then) {
              promises.push({
                function: bv[0],
                _this: bv[1],
                key: key
              });
            } else if (bv) {
              setError(key, bv);
            }
            return;
          } else {
            bv = new Validate(values[key], Object.assign({}, this$1.options, {message: message}))[type];
          }
          Object.keys(rule).forEach(function (r) {
            if (rule.required) {
              bv = bv.isRequired;
            }
            if (bv[r] && rule[r] && typeof bv[r] === 'object') {
              bv = bv[r];
            }
            if (bv[r] && rule[r] !== undefined&& typeof bv[r] === 'function') {
              bv = bv[r](rule[r]);
            }
          });
          bv.collect(function (error) {
            if (error) {
              setError(key, error);
            }
          });
        });
      }
    });
  }
  if (promises.length > 0) {
    Promise.all(promises.map(function (a) { return a.function; })).then(function () {
      promises.forEach(function (promise) {
        if (promise._this.error) {
          setError(promise.key, promise._this.error);
        }
      });
      callback && callback(errors);
    });
  } else {
    callback && callback(errors);
  }
};

exports.Schema = Schema;
exports.default = index;
