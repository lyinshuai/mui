"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.measure = void 0;
var React = __importStar(require("react"));
var react_dom_1 = require("react-dom");
var mergedToString_1 = __importDefault(require("../_util/mergedToString"));
function styleToString(style) {
    var styleNames = Array.prototype.slice.apply(style);
    return styleNames.map(function (name) { return name + ": " + style.getPropertyValue(name) + ";"; }).join('');
}
function pxToNumber(value) {
    if (!value)
        return 0;
    var match = value.match(/^\d*(\.\d*)?/);
    return match ? Number(match[0]) : 0;
}
var mirrorElement;
function measure(originElement, ellipsisConfig, operations, children) {
    var rows = ellipsisConfig.rows || 1;
    var ellipsisStr = ellipsisConfig.ellipsisStr !== undefined ? ellipsisConfig.ellipsisStr : '...';
    var suffix = ellipsisConfig.suffix !== undefined ? ellipsisConfig.suffix : '';
    if (!mirrorElement) {
        mirrorElement = document.createElement(originElement.tagName);
        document.body.appendChild(mirrorElement);
    }
    var originStyle = window.getComputedStyle(originElement);
    var styleString = styleToString(originStyle);
    mirrorElement.setAttribute('style', styleString);
    mirrorElement.setAttribute('aria-hidden', 'true');
    mirrorElement.style.height = 'auto';
    mirrorElement.style.minHeight = 'auto';
    mirrorElement.style.maxHeight = 'auto';
    mirrorElement.style.position = 'fixed';
    mirrorElement.style.left = '0';
    mirrorElement.style.top = '-99999999px';
    // mirrorElement.style.top = '200px';
    mirrorElement.style.zIndex = '-200';
    (0, react_dom_1.render)(React.createElement("span", null, operations), mirrorElement);
    var operationsChildNodes = Array.prototype.slice.apply(mirrorElement.childNodes[0].cloneNode(true).childNodes);
    var fullText = (0, mergedToString_1.default)(React.Children.toArray(children));
    (0, react_dom_1.unmountComponentAtNode)(mirrorElement);
    mirrorElement.innerHTML = '';
    var ellipsisTextNode = document.createTextNode("" + ellipsisStr + suffix);
    mirrorElement.appendChild(ellipsisTextNode);
    operationsChildNodes.forEach(function (childNode) {
        mirrorElement.appendChild(childNode);
    });
    var textNode = document.createTextNode(fullText);
    mirrorElement.insertBefore(textNode, mirrorElement.firstChild);
    var lineHeight = pxToNumber(originStyle.lineHeight);
    var maxHeight = Math.round(lineHeight * rows + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom));
    function inRange() {
        return mirrorElement.offsetHeight <= maxHeight;
    }
    if (inRange()) {
        (0, react_dom_1.unmountComponentAtNode)(mirrorElement);
        return { ellipsisText: fullText, ellipsis: false };
    }
    function measureText(textNode, startLoc, endLoc, lastSuccessLoc) {
        if (startLoc === void 0) { startLoc = 0; }
        if (endLoc === void 0) { endLoc = fullText.length; }
        if (lastSuccessLoc === void 0) { lastSuccessLoc = 0; }
        var midLoc = Math.floor((startLoc + endLoc) / 2);
        var currentText = fullText.slice(0, midLoc);
        textNode.textContent = currentText;
        if (startLoc >= endLoc - 1) {
            for (var step = endLoc; step >= startLoc; step -= 1) {
                var currentStepText = fullText.slice(0, step);
                textNode.textContent = currentStepText;
                if (inRange() || !currentStepText) {
                    return;
                }
            }
        }
        if (inRange()) {
            return measureText(textNode, midLoc, endLoc, midLoc);
        }
        return measureText(textNode, startLoc, midLoc, lastSuccessLoc);
    }
    measureText(textNode);
    return {
        text: textNode.textContent,
        ellipsis: true,
    };
}
exports.measure = measure;
